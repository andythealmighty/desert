<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>불완전함의 미학</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
    .info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-family: Arial, sans-serif;
      font-size: 14px;
      pointer-events: none;
      transition: opacity 1s;
    }
    .phase-title {
      position: absolute;
      top: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-family: Arial, sans-serif;
      font-size: 24px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 2s;
    }
  </style>
</head>
<body>
  <div class="info">마우스를 움직여 디저트를 생성하세요 | 클릭하여 단계 전환</div>
  <div class="phase-title"></div>
  
  <script type="module">
    // Three.js 모듈 불러오기
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    
    // 메인 변수
    let scene, camera, renderer, composer;
    let controls;
    let desserts = [];
    let discardedDesserts = [];
    let perfectDesserts = [];
    let clock;
    let mousePosition;
    let raycaster;
    let targetPosition;
    let cameraTarget;
    let phase = 0;
    let phaseTimer = 0;
    let transformationStarted = false;
    let particles = [];
    
    // 페이즈 제목
    const phaseTitles = [
      "열정 - 디저트를 향한 사랑",
      "현실 - 완벽함의 그림자",
      "승화 - 불완전함의 아름다움"
    ];
    
    // 색상 팔레트
    const palette = {
      cream: new THREE.Color(0xffefd5),
      pink: new THREE.Color(0xffb6c1),
      chocolate: new THREE.Color(0x8b4513),
      mint: new THREE.Color(0x98fb98),
      lavender: new THREE.Color(0xe6e6fa),
      peach: new THREE.Color(0xffdab9),
      blueberry: new THREE.Color(0x4682b4)
    };
    
    // 초기화 및 애니메이션
    init();
    animate();
    
    function init() {
      try {
        // 기본 객체 초기화
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.FogExp2(0x0a0a1a, 0.02);
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 0, 0);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // 포스트 프로세싱 설정
        setupPostProcessing();
        
        // 추가 객체 초기화
        clock = new THREE.Clock();
        mousePosition = new THREE.Vector2();
        raycaster = new THREE.Raycaster();
        targetPosition = new THREE.Vector3(0, 5, 15);
        cameraTarget = new THREE.Vector3(0, 0, 0);
        
        // 씬 설정
        setupLights();
        createFloor();
        
        // 초기 디저트 생성
        createInitialDesserts();
        
        // 컨트롤 설정
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        
        // 이벤트 리스너
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        
        // 초기 페이즈 타이틀 표시
        updatePhaseTitle();
        
        console.log("초기화 완료");
      } catch (e) {
        console.error("초기화 오류:", e);
      }
    }
    
    function setupPostProcessing() {
      // 블룸 효과 설정
      const renderPass = new RenderPass(scene, camera);
      
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.8,  // 강도
        0.3,  // 반경
        0.7   // 임계값
      );
      
      composer = new EffectComposer(renderer);
      composer.addPass(renderPass);
      composer.addPass(bloomPass);
    }
    
    function setupLights() {
      // 앰비언트 라이트
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);
      
      // 디렉셔널 라이트
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // 감정의 충돌을 표현하는 조명 (따뜻한 색과 차가운 색)
      const warmLight = new THREE.PointLight(0xff9966, 1, 20);
      warmLight.position.set(-5, 5, 5);
      scene.add(warmLight);
      
      const coolLight = new THREE.PointLight(0x6699ff, 1, 20);
      coolLight.position.set(5, 5, -5);
      scene.add(coolLight);
    }
    
    function createFloor() {
      // 바닥면 생성 - 추상적인 표면
      const floorGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
      
      // 바닥에 노이즈 적용
      const positions = floorGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        
        // 가장자리는 평평하게, 중앙은 약간 울퉁불퉁하게
        const distance = Math.sqrt(x * x + y * y);
        const noiseValue = Math.sin(x * 0.1) * Math.cos(y * 0.1) * Math.max(0, 1 - distance / 25);
        
        positions.setZ(i, noiseValue * 0.5);
      }
      
      floorGeometry.computeVertexNormals();
      
      // 바닥 재질
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x222233,
        roughness: 0.8,
        metalness: 0.2,
        side: THREE.DoubleSide,
        flatShading: true
      });
      
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      floor.receiveShadow = true;
      scene.add(floor);
    }
    
    function createInitialDesserts() {
      // 초기 디저트 생성
      for (let i = 0; i < 8; i++) {
        createDessert(
          Math.random() * 10 - 5,
          Math.random() * 3,
          Math.random() * 10 - 5
        );
      }
    }
    
    function createDessert(x, y, z) {
      // 디저트 타입 랜덤 선택
      const dessertType = Math.floor(Math.random() * 3);
      
      // 색상 선택
      const colorKeys = Object.keys(palette);
      const baseColor = palette[colorKeys[Math.floor(Math.random() * colorKeys.length)]];
      const accentColor = palette[colorKeys[Math.floor(Math.random() * colorKeys.length)]];
      
      // 크기 랜덤화
      const size = 0.5 + Math.random() * 0.5;
      
      // 불완전함 정도
      const imperfection = Math.random();
      
      // 디저트 생성
      let dessertObj;
      
      if (dessertType === 0) {
        // 추상적 케이크
        dessertObj = createAbstractCake(size, baseColor, accentColor, imperfection);
      } else if (dessertType === 1) {
        // 추상적 마카롱
        dessertObj = createAbstractMacaron(size, baseColor, accentColor, imperfection);
      } else {
        // 추상적 쿠키
        dessertObj = createAbstractCookie(size, baseColor, accentColor, imperfection);
      }
      
      // 위치 설정
      dessertObj.position.set(x, y, z);
      
      // 그림자 설정
      dessertObj.castShadow = true;
      dessertObj.receiveShadow = true;
      
      // 디저트 속성 저장
      dessertObj.userData = {
        type: dessertType,
        imperfection: imperfection,
        originalY: y,
        fallSpeed: 0.05 + Math.random() * 0.1,
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.05,
          z: (Math.random() - 0.5) * 0.05
        },
        discarded: imperfection > 0.3,
        transformationProgress: 0
      };
      
      // 씬에 추가
      scene.add(dessertObj);
      desserts.push(dessertObj);
      
      // 불완전한 디저트는 버려진 배열에 추가
      if (imperfection > 0.3) {
        discardedDesserts.push(dessertObj);
      } else {
        perfectDesserts.push(dessertObj);
      }
      
      return dessertObj;
    }
    
    function createAbstractCake(size, baseColor, accentColor, imperfection) {
      // 케이크 그룹
      const cakeGroup = new THREE.Group();
      
      // 케이크 층 (2-3개)
      const layers = 2 + Math.floor(Math.random() * 2);
      let currentHeight = 0;
      
      for (let i = 0; i < layers; i++) {
        const layerHeight = size * (0.3 + Math.random() * 0.2);
        const layerRadius = size * (1.0 - i * 0.2);
        
        const layerGeometry = new THREE.CylinderGeometry(
          layerRadius, layerRadius, layerHeight, 16, 1, false
        );
        
        // 불완전함 적용
        if (imperfection > 0.3) {
          distortGeometry(layerGeometry, imperfection);
        }
        
        // 층마다 약간 다른 색상
        const layerColor = baseColor.clone().lerp(accentColor, i / layers * 0.5);
        const layerMaterial = new THREE.MeshStandardMaterial({
          color: layerColor,
          roughness: 0.7,
          metalness: 0.1
        });
        
        const layer = new THREE.Mesh(layerGeometry, layerMaterial);
        layer.position.y = currentHeight + layerHeight / 2;
        layer.castShadow = true;
        layer.receiveShadow = true;
        
        cakeGroup.add(layer);
        currentHeight += layerHeight;
      }
      
      // 케이크 위 장식 (추상적인 형태)
      if (Math.random() > 0.3) {
        const toppingGeometry = new THREE.SphereGeometry(size * 0.3, 8, 8);
        
        if (imperfection > 0.3) {
          distortGeometry(toppingGeometry, imperfection * 0.5);
        }
        
        const toppingMaterial = new THREE.MeshStandardMaterial({
          color: accentColor,
          roughness: 0.6,
          metalness: 0.2
        });
        
        const topping = new THREE.Mesh(toppingGeometry, toppingMaterial);
        topping.position.y = currentHeight + size * 0.2;
        topping.castShadow = true;
        
        cakeGroup.add(topping);
      }
      
      return cakeGroup;
    }
    
    function createAbstractMacaron(size, baseColor, accentColor, imperfection) {
      // 마카롱 그룹
      const macaronGroup = new THREE.Group();
      
      // 위, 아래 반구
      const halfHeight = size * 0.2;
      
      // 위쪽 반구
      const topGeometry = new THREE.SphereGeometry(
        size, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2
      );
      
      if (imperfection > 0.3) {
        distortGeometry(topGeometry, imperfection);
      }
      
      const topMaterial = new THREE.MeshStandardMaterial({
        color: baseColor,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const topHalf = new THREE.Mesh(topGeometry, topMaterial);
      topHalf.position.y = halfHeight;
      topHalf.castShadow = true;
      topHalf.receiveShadow = true;
      
      macaronGroup.add(topHalf);
      
      // 아래쪽 반구
      const bottomGeometry = new THREE.SphereGeometry(
        size, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2
      );
      
      if (imperfection > 0.3) {
        distortGeometry(bottomGeometry, imperfection);
      }
      
      const bottomMaterial = new THREE.MeshStandardMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.2),
        roughness: 0.7,
        metalness: 0.1
      });
      
      const bottomHalf = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottomHalf.position.y = -halfHeight;
      bottomHalf.castShadow = true;
      bottomHalf.receiveShadow = true;
      
      macaronGroup.add(bottomHalf);
      
      // 가운데 필링
      const fillingGeometry = new THREE.CylinderGeometry(
        size * 0.8, size * 0.8, halfHeight * 0.5, 16, 1, false
      );
      
      if (imperfection > 0.3) {
        distortGeometry(fillingGeometry, imperfection * 0.5);
      }
      
      const fillingMaterial = new THREE.MeshStandardMaterial({
        color: accentColor,
        roughness: 0.6,
        metalness: 0.2
      });
      
      const filling = new THREE.Mesh(fillingGeometry, fillingMaterial);
      filling.castShadow = true;
      filling.receiveShadow = true;
      
      macaronGroup.add(filling);
      
      return macaronGroup;
    }
    
    function createAbstractCookie(size, baseColor, accentColor, imperfection) {
      // 쿠키 그룹
      const cookieGroup = new THREE.Group();
      
      // 기본 쿠키 형태 - 납작한 원반
      const cookieGeometry = new THREE.CylinderGeometry(
        size, size * 1.05, size * 0.3, 16, 1, false
      );
      
      // 불완전함 적용 - 쿠키 가장자리 불규칙하게
      if (imperfection > 0.3) {
        distortGeometry(cookieGeometry, imperfection);
      }
      
      const cookieMaterial = new THREE.MeshStandardMaterial({
        color: baseColor,
        roughness: 0.9,
        metalness: 0.1
      });
      
      const cookie = new THREE.Mesh(cookieGeometry, cookieMaterial);
      cookie.castShadow = true;
      cookie.receiveShadow = true;
      
      cookieGroup.add(cookie);
      
      // 초콜릿 칩 추가
      const chipCount = 3 + Math.floor(Math.random() * 5);
      
      for (let i = 0; i < chipCount; i++) {
        const chipSize = size * (0.1 + Math.random() * 0.1);
        const chipGeometry = new THREE.SphereGeometry(chipSize, 8, 8);
        
        const chipMaterial = new THREE.MeshStandardMaterial({
          color: accentColor,
          roughness: 0.6,
          metalness: 0.3
        });
        
        const chip = new THREE.Mesh(chipGeometry, chipMaterial);
        
        // 랜덤 위치 (쿠키 위에)
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * size * 0.7;
        chip.position.set(
          Math.cos(angle) * radius,
          size * 0.15,
          Math.sin(angle) * radius
        );
        
        chip.castShadow = true;
        cookieGroup.add(chip);
      }
      
      return cookieGroup;
    }
    
    function distortGeometry(geometry, intensity) {
      // 지오메트리에 불규칙성 추가
      const positions = geometry.attributes.position;
      
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // 노이즈 기반 변형
        const noiseValue = (
          Math.sin(x * 2 + y * 3) * 
          Math.cos(y * 2 + z * 2) * 
          Math.sin(z * 2 + x * 3)
        ) * intensity * 0.2;
        
        positions.setX(i, x + noiseValue);
        positions.setY(i, y + noiseValue);
        positions.setZ(i, z + noiseValue);
      }
      
      geometry.computeVertexNormals();
    }
    
    function createParticle(x, y, z, color) {
      // 파티클 생성 (변형 단계에서 사용)
      const geometry = new THREE.SphereGeometry(0.1, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      particle.position.set(x, y, z);
      
      // 파티클 속성
      particle.userData = {
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.05,
          Math.random() * 0.1,
          (Math.random() - 0.5) * 0.05
        ),
        life: 100 + Math.random() * 100
      };
      
      scene.add(particle);
      particles.push(particle);
      
      return particle;
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      try {
        const delta = clock.getDelta();
        
        // 페이즈에 따른 업데이트
        switch(phase) {
          case 0:
            updatePhaseZero(delta);
            break;
          case 1:
            updatePhaseOne(delta);
            break;
          case 2:
            updatePhaseTwo(delta);
            break;
        }
        
        // 파티클 업데이트
        updateParticles();
        
        // 페이즈 타이머 업데이트
        phaseTimer += delta;
        
        // 컨트롤 업데이트
        controls.update();
        
        // 카메라 업데이트
        updateCamera(delta);
        
        // 렌더링
        composer.render();
      } catch (e) {
        console.error("애니메이션 오류:", e);
      }
    }
    
    function updatePhaseZero(delta) {
      // 열정 페이즈 - 디저트에 대한 사랑
      for (let i = 0; i < desserts.length; i++) {
        const dessert = desserts[i];
        
        // 디저트가 부드럽게 회전
        dessert.rotation.y += 0.01;
        
        // 디저트가 위아래로 떠다님
        const hoverHeight = dessert.userData.originalY + Math.sin(clock.elapsedTime + i) * 0.2;
        dessert.position.y = hoverHeight;
        
        // 가끔 파티클 생성
        if (Math.random() > 0.98) {
          const childColor = dessert.children[0].material.color.clone();
          createParticle(
            dessert.position.x,
            dessert.position.y,
            dessert.position.z,
            childColor
          );
        }
      }
    }
    
    function updatePhaseOne(delta) {
      // 현실 페이즈 - 완벽함과 불완전함의 분리
      for (let i = 0; i < desserts.length; i++) {
        const dessert = desserts[i];
        
        if (dessert.userData.discarded) {
          // 불완전한 디저트는 떨어짐
          if (dessert.position.y > -4.5) {
            dessert.position.y -= dessert.userData.fallSpeed;
            
            // 회전
            dessert.rotation.x += dessert.userData.rotationSpeed.x;
            dessert.rotation.y += dessert.userData.rotationSpeed.y;
            dessert.rotation.z += dessert.userData.rotationSpeed.z;
            
            // 떨어지는 과정에서 파티클 생성
            if (Math.random() > 0.95) {
              const childColor = dessert.children[0].material.color.clone();
              createParticle(
                dessert.position.x,
                dessert.position.y,
                dessert.position.z,
                childColor
              );
            }
          } else {
            // 바닥에 닿으면 고정
            dessert.position.y = -4.5;
          }
        } else {
          // 완벽한 디저트는 공중에 떠 있음
          const hoverHeight = dessert.userData.originalY + Math.sin(clock.elapsedTime + i) * 0.2;
          dessert.position.y = hoverHeight;
          
          // 부드럽게 회전
          dessert.rotation.y += 0.01;
          
          // 빛나는 효과
          dessert.children.forEach(child => {
            if (child.material && child.material.emissive) {
              const pulseIntensity = 0.2 + Math.sin(clock.elapsedTime * 2 + i) * 0.1;
              child.material.emissive.setRGB(pulseIntensity, pulseIntensity, pulseIntensity);
            } else if (child.material) {
              child.material.emissive = new THREE.Color(0.1, 0.1, 0.1);
            }
          });
        }
      }
      
      // 일정 시간 후 자동으로 다음 단계로
      if (phaseTimer > 15 && !transformationStarted) {
        phase = 2;
        phaseTimer = 0;
        transformationStarted = true;
        updatePhaseTitle();
      }
    }
    
    function updatePhaseTwo(delta) {
      // 승화 페이즈 - 불완전함의 아름다움
      
      // 카메라 위치 변경
      targetPosition.set(0, 10, 20);
      cameraTarget.set(0, 0, 0);
      
      // 완벽한 디저트는 계속 떠 있음
      for (let i = 0; i < perfectDesserts.length; i++) {
        const dessert = perfectDesserts[i];
        
        // 부드럽게 회전
        dessert.rotation.y += 0.01;
        
        // 위아래로 떠다님
        const hoverHeight = dessert.userData.originalY + Math.sin(clock.elapsedTime + i) * 0.2;
        dessert.position.y = hoverHeight;
      }
      
      // 불완전한 디저트들이 변형
      for (let i = 0; i < discardedDesserts.length; i++) {
        const dessert = discardedDesserts[i];
        
        // 변형 진행 업데이트
        dessert.userData.transformationProgress += delta * 0.2;
        const progress = Math.min(1, dessert.userData.transformationProgress);
        
        if (progress < 1) {
          // 목표 위치 계산 - 하트 모양 패턴
          const t = dessert.userData.transformationProgress * Math.PI * 2;
          const angleOffset = i * (Math.PI * 2 / discardedDesserts.length);
          
          // 하트 모양 수식
          const heartShape = (t) => {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return { x: x, y: y };
          };
          
          const heart = heartShape(t + angleOffset);
          const targetX = heart.x * 0.3;
          const targetZ = heart.y * 0.3;
          const targetY = -4.5 + progress * 8; // 점점 위로 올라감
          
          // 현재 위치에서 목표 위치로 부드럽게 이동
          dessert.position.x += (targetX - dessert.position.x) * 0.05;
          dessert.position.z += (targetZ - dessert.position.z) * 0.05;
          dessert.position.y += (targetY - dessert.position.y) * 0.05;
          
          // 회전
          dessert.rotation.y += 0.02;
          
          // 색상 변화 - 모든 자식 요소에 적용
          dessert.children.forEach(child => {
            if (child.material) {
              // 새로운 색상 계산
              const targetColor = new THREE.Color(
                0.8 + Math.sin(t + angleOffset) * 0.2,
                0.8 + Math.sin(t + angleOffset + Math.PI/2) * 0.2,
                0.8 + Math.sin(t + angleOffset + Math.PI) * 0.2
              );
              
              // 색상 부드럽게 변경
              child.material.color.lerp(targetColor, 0.05);
              
              // 빛나는 효과 추가
              if (!child.material.emissive) {
                child.material.emissive = new THREE.Color();
              }
              child.material.emissive.lerp(new THREE.Color(0.2, 0.2, 0.3), 0.05);
            }
          });
          
          // 파티클 생성
          if (Math.random() > 0.9) {
            const childColor = dessert.children[0].material.color.clone();
            createParticle(
              dessert.position.x,
              dessert.position.y,
              dessert.position.z,
              childColor
            );
          }
        }
      }
    }
    
    function updateParticles() {
      // 파티클 업데이트
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // 위치 업데이트
        particle.position.add(particle.userData.velocity);
        
        // 크기 감소
        particle.scale.multiplyScalar(0.98);
        
        // 투명도 감소
        particle.material.opacity *= 0.98;
        
        // 수명 감소
        particle.userData.life--;
        
        // 수명이 다한 파티클 제거
        if (particle.userData.life <= 0 || particle.material.opacity < 0.01) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
    }
    
    function updateCamera(delta) {
      // 카메라 부드럽게 이동
      if (targetPosition) {
        camera.position.lerp(targetPosition, delta * 0.1);
      }
      
      // 카메라 타겟 부드럽게 이동
      if (controls && controls.target && cameraTarget) {
        controls.target.lerp(cameraTarget, delta * 0.1);
      }
    }
    
    function updatePhaseTitle() {
      // 페이즈 타이틀 업데이트
      const titleElement = document.querySelector('.phase-title');
      titleElement.textContent = phaseTitles[phase];
      titleElement.style.opacity = 1;
      
      // 3초 후 타이틀 페이드 아웃
      setTimeout(() => {
        titleElement.style.opacity = 0;
      }, 3000);
    }
    
    function onMouseMove(event) {
      // 마우스 위치 업데이트
      mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      // 레이캐스터 업데이트
      raycaster.setFromCamera(mousePosition, camera);
      
      // 바닥과의 교차점 계산
      const intersects = raycaster.intersectObjects(scene.children);
      
      // 페이즈 0과 1에서만 마우스로 디저트 생성
      if (phase < 2) {
        for (let i = 0; i < intersects.length; i++) {
          const intersect = intersects[i];
          
          // 일정 확률로 디저트 생성
          if (Math.random() < 0.03 && desserts.length < 50) {
            createDessert(
              intersect.point.x,
              intersect.point.y + 1,
              intersect.point.z
            );
          }
        }
      }
    }
    
    function onClick() {
      // 클릭 시 페이즈 전환
      phase = (phase + 1) % 3;
      phaseTimer = 0;
      
      // 페이즈에 따른 설정
      if (phase === 0) {
        // 초기 페이즈로 리셋
        targetPosition.set(0, 5, 15);
        cameraTarget.set(0, 0, 0);
        transformationStarted = false;
        
        // 모든 디저트 제거
        for (let i = desserts.length - 1; i >= 0; i--) {
          scene.remove(desserts[i]);
        }
        
        // 모든 파티클 제거
        for (let i = particles.length - 1; i >= 0; i--) {
          scene.remove(particles[i]);
        }
        
        desserts = [];
        discardedDesserts = [];
        perfectDesserts = [];
        particles = [];
        
        // 새 디저트 생성
        createInitialDesserts();
        
      } else if (phase === 1) {
        // 현실 페이즈
        targetPosition.set(5, 8, 15);
        cameraTarget.set(0, 0, 0);
        
      } else if (phase === 2) {
        // 승화 페이즈
        transformationStarted = true;
      }
      
      // 페이즈 타이틀 업데이트
      updatePhaseTitle();
    }
    
    function onWindowResize() {
      // 윈도우 크기 변경 시 업데이트
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
